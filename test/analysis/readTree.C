#include "TROOT.h"
#include "TFile.h"
#include "TTree.h"
#include "TBrowser.h"
#include "TH2.h"
#include "TRandom.h"
#include "HoughTransform.C"
#include "../../interface/HGCEventSummary.h"

#include <iostream>

using namespace std;

void readTree(TString url="../../HGCHits_22.root")
{
  //read the Tree generated by tree1w and fill two histograms
  
  //note that we use "new" to create the TFile and TTree objects !
  //because we want to keep these objects alive when we leave this function.
  TFile *f = new TFile(url);
  TTree *HGC = (TTree*)f->Get("hgcAnalyzer/HGC");

  HGCEvent::HGCEvent_t hgcEv;
  HGCEvent::attachToTree(HGC, hgcEv);
   
  //create two histograms
  TObjArray allHistos;
  Float_t eranges[]={0,10,25,40};
  std::vector<TH1F *> hlayer,elayer,eratio;
  for(size_t icut=0; icut<sizeof(eranges)/sizeof(Float_t); icut++)
    {
      TString pfix(""); if(eranges[icut]>0) pfix += eranges[icut];
      hlayer.push_back(new TH1F("hlayer"+pfix,";Layer number; #hits",100,0,100) );     allHistos.Add(hlayer[icut]);
      elayer.push_back(new TH1F("elayer"+pfix,";Layer number; Energy",100,0,100) );    allHistos.Add(elayer[icut]);
      eratio.push_back(new TH1F("eratio"+pfix,";E_{max}/E_{shower};Events",100,0,2) ); allHistos.Add(eratio[icut]);
    }
  TH2F *xzview   = new TH2F("xzview",";z [cm]; x[cm]; Energy",460,310,540,575,-287.5,287.5); allHistos.Add(xzview);

  //format histos
  for(Int_t ih=0; ih<allHistos.GetEntriesFast(); ih++)
    {
      ((TH1 *)allHistos.At(ih))->Sumw2();
      ((TH1 *)allHistos.At(ih))->SetDirectory(0);
    }

  //prepare an output ROOT file
  TFile *fOut=TFile::Open("ReadTree.root","RECREATE");

  //read all entries and fill the histograms
  Long64_t nentries = HGC->GetEntries();
  for (Long64_t i=0;i<nentries;i++) {

    HGC->GetEntry(i);

    //generated event energy
    Float_t genEn=hgcEv.gen_en[0];
    
    //analyze the shower of this particle
    Float_t totalEn(0);
    xzview->Reset("ICE");
    for(Long64_t ihit=0; ihit<hgcEv.nhits; ihit++)
      {
	//particle gun is shooting only in the positive endcap
	if(hgcEv.hit_z[ihit]<0) continue;

	//convert reconstructed hit energy to MIP units
	Float_t mipEn(55.1);
	Int_t layer=hgcEv.hit_layer[ihit];
	if(hgcEv.hit_type[ihit]==1) { layer+=30;    mipEn=85.1; }
	if(hgcEv.hit_type[ihit]==2) { layer+=30+12; mipEn=1498.4; }
	Float_t recEn=hgcEv.hit_edep[ihit]/mipEn;

	//fill histograms
	totalEn += recEn;
	for(size_t icut=0; icut<sizeof(eranges)/sizeof(Float_t); icut++)
	  {
	    if(eranges[icut]==0 || genEn<eranges[icut])
	      {
		hlayer[icut]->Fill(layer,1./nentries);
		elayer[icut]->Fill(layer,recEn/nentries);
	      }
	  }
	xzview->Fill(hgcEv.hit_z[ihit], hgcEv.hit_x[ihit], recEn);
      }

    //perform the Hough transform of the reconstructed hits position
    std::pair<TH2F *,TH2F *>houghview=HoughTransform(xzview);     
    Float_t maxEn(houghview.second->GetMaximum());
    for(size_t icut=0; icut<sizeof(eranges)/sizeof(Float_t); icut++)
      {
	if(eranges[icut]==0 || genEn<eranges[icut])
	  {
	    eratio[icut]->Fill( maxEn / totalEn );
	  }
      }
    
    //save Hough transform and event view to output
    fOut->cd();
    TString header("event"); header+=i;
    houghview.second->Clone( header + "_weightedhough" )->Write();
    xzview->Clone( header + "_xz" )->Write();
    delete houghview.first;
    delete houghview.second;
    
    //go back to file being read
    f->cd();
  }
  
  //close input file
  f->Close();

  //save histos to output file   
  fOut->cd();
  for(Int_t ih=0; ih<allHistos.GetEntriesFast(); ih++)
    {
      ((TH1 *)allHistos.At(ih))->SetDirectory(fOut);
      allHistos.At(ih)->Write();
    }
  fOut->Close();

}   

